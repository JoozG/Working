# app/streamlit_app.py
from __future__ import annotations
import os, sys
import numpy as np
import pandas as pd
import streamlit as st
from collections import Counter
import pathlib
from fasta_processing import read_fasta_bytes, dnaOperations, rnaConverter, proteinOperations
import altair as alt

# ===== Helpers for preview & HTML export =====
def wrap_seq(s: str, width: int = 60) -> str:
    return "\n".join(s[i:i+width] for i in range(0, len(s), width))

def html_table_from_df(df: pd.DataFrame) -> str:
    return df.to_html(index=False, escape=True)

def build_html_report(title: str, sections: list[tuple[str, str]]) -> str:
    # sections: list of (heading, html_content)
    css = """
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:32px;}
    h1{margin-bottom:0.2rem} h2{margin-top:1.6rem}
    table{border-collapse:collapse;width:100%} td,th{border:1px solid #ddd;padding:6px 8px}
    th{background:#f6f6f6;text-align:left}
    code,pre{background:#f7f7f7;padding:8px;border-radius:6px;display:block;white-space:pre-wrap}
    .meta{opacity:.75;font-size:.9rem}
    """
    parts = [f"<html><head><meta charset='utf-8'><title>{title}</title><style>{css}</style></head><body>"]
    parts.append(f"<h1>{title}</h1><p class='meta'>Generated by Streamlit app</p>")
    for h, content in sections:
        parts.append(f"<h2>{h}</h2>")
        parts.append(content)
    parts.append("</body></html>")
    return "".join(parts)

SAMPLE_PATHS = {
    "DNA": pathlib.Path(__file__).resolve().parent.parent / "sampledata" / "example-dna.fasta",
    "RNA": pathlib.Path(__file__).resolve().parent.parent / "sampledata" / "example-rna.fasta",
    "Protein": pathlib.Path(__file__).resolve().parent.parent / "sampledata" / "example-protein.fasta",
}

def get_sample_bytes(mode: str) -> bytes:
    key = "DNA" if mode == "DNA" else ("RNA" if mode.startswith("RNA") else "Protein")
    return SAMPLE_PATHS[key].read_bytes()

st.set_page_config(page_title="FASTA Processing", page_icon="ðŸ§¬", layout="wide")

# ============= STYLE =============
st.markdown("""
<style>
/* Hard-override Streamlit CSS variables */
:root {
  --primary-color: #1E88E5;
  --text-color: #1F2937;
  --background-color: #F5F7FA;
  --secondary-background-color: #E3F2FD;
}

/* Headings */
h1, h2, h3 { color: #1565C0; }

/* Buttons (primary) */
div.stButton > button[kind="primary"] {
  background: #1E88E5;
  color: #fff;
  border-radius: 8px;
}
div.stButton > button[kind="primary"]:hover {
  background: #1565C0;
}

/* Dataframe container */
section[data-testid="stDataFrame"] {
  background: #ffffff;
  border: 1px solid #dce1e7;
  border-radius: 8px;
}

/* Tabs underline accent */
button[data-baseweb="tab"] {
  color: #1F2937;
}
button[aria-selected="true"][data-baseweb="tab"] {
  color: #1565C0;
  border-bottom: 3px solid #1E88E5;
}
</style>
""", unsafe_allow_html=True)

# ============= SIDEBAR (left side-peek) =============
with st.sidebar:
    st.header("ðŸ“¥ Input & options")
    mode = st.selectbox("Analysis mode", ["DNA", "RNAâ†’Protein", "Protein"])

    use_sample = st.toggle(
        "Use sample dataset",
        value=True,
        help="If enabled, a built-in example is loaded instead of your file."
    )

    if not use_sample:
        upl = st.file_uploader(
            "Upload FASTA file",
            type=["fa", "fasta", "fna", "faa", "fas"],
            help="One or more sequences in FASTA format."
        )
    else:
        upl = None  # we will read from sampledata/

    st.markdown("---")
    st.caption("Filters / charts")
    min_len = st.number_input("Min length", min_value=0, value=0, step=50)
    max_len = st.number_input("Max length (0 = no limit)", min_value=0, value=0, step=1000)
    bins = st.slider("Histogram bins", min_value=5, max_value=100, value=40)
    top_n = st.slider("Top N (codons/AA)", min_value=5, max_value=60, value=20)
    st.markdown("---")
    st.markdown("Developed by MichaÅ‚ Milewski")

st.title("ðŸ§¬ FASTA Processing â€” stats & visualization")

with st.expander("What is a FASTA file? Click to see format details.", expanded=False):
    st.markdown(
        """
        A FASTA file is a plain-text format used to store biological sequences (DNA, RNA, protein).

        **Structure:**
        - Each sequence starts with a header line beginning with `>` followed by an identifier (and optionally a description).
        - The following lines contain the sequence itself (A/C/G/T or A/C/G/U for nucleotides, 20 letters for amino acids).
        - Lines are usually wrapped at ~60â€“80 characters, but wrapping is not strictly required.

        **Example (DNA):**
        ```
        >seq1 human mitochondrion
        ATGCTACCTCCTCAAGTACATGAGCTGTTGGCAG
        >seq2 E.coli plasmid fragment
        GCGTATGCTAGCTGATCGATCGTAGCTAGCATCGATCG
        ```
        """
    )

# ===== Resolve data source (sample or user upload) =====
if use_sample:
    data_bytes = get_sample_bytes(mode)
else:
    if not upl:
        st.info("Upload a FASTA file on the left, or enable the sample dataset.")
        st.stop()
    data_bytes = upl.read()

@st.cache_data(show_spinner=False)
def load_seqs(data: bytes) -> dict[str, str]:
    return read_fasta_bytes(data)

seqs = load_seqs(data_bytes)
if not seqs:
    st.error("No sequences found.")
    st.stop()

# (opcjonalnie) baner informacyjny
if use_sample:
    st.info(
        "Showing analysis for sample dataset: **{}** (from `sampledata/`).".format(
            "DNA" if mode=="DNA" else ("RNA" if mode.startswith("RNA") else "Protein")
        )
    )

# ============= HELPERS =============
def apply_length_filters(df: pd.DataFrame) -> pd.DataFrame:
    out = df
    if min_len > 0:
        out = out[out["length"] >= min_len]
    if max_len > 0:
        out = out[out["length"] <= max_len]
    return out

def length_barchart(series: pd.Series, title: str, x_title: str):
    """
    Draw a bar chart of exact integer sequence lengths.
    """
    counts = series.value_counts().sort_index()
    data = pd.DataFrame({"length": counts.index, "count": counts.values})
    chart = (
        alt.Chart(data)
        .mark_bar()
        .encode(
            x=alt.X("length:O", title=x_title),  # O = ordinal, dziÄ™ki temu wartoÅ›ci sÄ… dyskretne
            y=alt.Y("count:Q", title="count")
        )
        .properties(title=title, width="container", height=300)
    )
    return chart

def fixed_histogram(series: pd.Series, title: str, x_title: str, x_domain: tuple[int|float, int|float], maxbins: int = 40):
    s = pd.Series(series).dropna().astype(float)
    data = pd.DataFrame({"x": s.to_numpy()})
    chart = (
        alt.Chart(data)
        .mark_bar()
        .encode(
            x=alt.X("x:Q",
                    bin=alt.Bin(maxbins=int(maxbins)),
                    scale=alt.Scale(domain=list(x_domain)),
                    title=x_title),
            y=alt.Y("count():Q", title="count")
        )
        .properties(title=title, width="container", height=240)
    )
    return chart

# ============= DNA MODE =============
if mode == "DNA":
    rows = []
    agg_counts = Counter()
    for sid, seq in seqs.items():
        seq_u = seq.upper().strip()
        length_raw = len(seq_u)
        gc_val = None
        counts = {"A": seq_u.count("A"), "C": seq_u.count("C"), "G": seq_u.count("G"), "T": seq_u.count("T")}
        try:
            dna = dnaOperations(seq)
            gc_val = dna.gc_content()
            counts = dna.nuc_count()

        except Exception:
            pass  # keep defaults

        agg_counts.update({k: counts.get(k, 0) for k in ("A", "C", "G", "T")})
        rows.append(
            {
                "id": sid,
                "length": len(seq),
                "GC%": gc_val,
                "A": counts.get("A", 0),
                "C": counts.get("C", 0),
                "G": counts.get("G", 0),
                "T": counts.get("T", 0),
            }
        )
    df = pd.DataFrame(rows).sort_values("length", ascending=False).reset_index(drop=True)
    df_f = apply_length_filters(df)

    t1, t2, t3 = st.tabs(["Summary", "Distributions", "Details"])

    with t1:
        c1, c2, c3, c4 = st.columns(4)
        c1.metric("Sequences", f"{len(df_f):,}".replace(",", " "))
        c2.metric("Mean length", f"{df_f['length'].mean():.1f}" if len(df_f) else "â€“")
        c3.metric("Median length", f"{df_f['length'].median():.1f}" if len(df_f) else "â€“")
        c4.metric("Avg GC%", f"{df_f['GC%'].mean():.2f}" if len(df_f) else "â€“")
        st.dataframe(df_f, use_container_width=True)

        #per-sequence preview (original / complement / reverse-comp / RNA) ---
        if len(df_f):
            st.markdown("#### Preview sequence")
            picked_id = st.selectbox("Select sequence ID", options=df_f["id"].tolist())
            if picked_id in seqs:
                dna_prev = dnaOperations(seqs[picked_id])
                orig = seqs[picked_id].upper()
                comp = "".join(dna_prev.complement())
                revc = "".join(dna_prev.reverse_complement())
                rna  = "".join(dna_prev.transcribe_dna_to_rna())
                col_a, col_b = st.columns(2)
                with col_a:
                    st.caption("Original (5'â†’3')")
                    st.code(wrap_seq(orig), language="text")
                    st.caption("Complement (3'â†’5')")
                    st.code(wrap_seq(comp), language="text")
                with col_b:
                    st.caption("Reverse-complement (5'â†’3')")
                    st.code(wrap_seq(revc), language="text")
                    st.caption("Transcribed RNA")
                    st.code(wrap_seq(rna), language="text")

    with t2:
        st.subheader("Length histogram")
        if len(df_f):
            st.altair_chart(
                length_barchart(df_f["length"], "DNA sequence length distribution", "length (nt)"),
                use_container_width=True
            )

        st.subheader("GC% distribution")
        if len(df_f):
            gc_series = df_f["GC%"].dropna()
            if len(gc_series):
                st.altair_chart(
                    fixed_histogram(gc_series, "GC% distribution", "GC% (0â€“100)", (0, 100), maxbins=bins),
                    use_container_width=True
                )


        st.subheader("Global nucleotide composition")
        comp_df = pd.DataFrame.from_dict(agg_counts, orient="index", columns=["count"]).loc[["A","C","G","T"]]
        st.bar_chart(comp_df)

    with t3:
        st.download_button(
            "Download CSV",
            df_f.to_csv(index=False).encode("utf-8"),
            file_name="dna_stats.csv",
            mime="text/csv",
        )
        # --- HTML report export ---
        html = build_html_report(
            title="DNA Statistics Report",
            sections=[
                ("Summary metrics",
                 f"<ul>"
                 f"<li>Sequences: <b>{len(df_f)}</b></li>"
                 f"<li>Mean length: <b>{(df_f['length'].mean() if len(df_f) else 0):.1f}</b></li>"
                 f"<li>Median length: <b>{(df_f['length'].median() if len(df_f) else 0):.1f}</b></li>"
                 f"<li>Average GC%: <b>{(df_f['GC%'].mean() if len(df_f) else 0):.2f}</b></li>"
                 f"</ul>"),
                ("Per-sequence table", html_table_from_df(df_f)),
            ],
        )
        st.download_button("Download HTML report", html, file_name="dna_report.html", mime="text/html")

# ============= RNA â†’ PROTEIN MODE =============
elif mode == "RNAâ†’Protein":
    rows = []
    codon_usage_global = Counter()
    orf_lengths = []
    orf_examples = {}

    def fix_frame(rna_s: str) -> str:
        rna_s = rna_s.upper().strip()
        return rna_s[: (len(rna_s) // 3) * 3] 

    for sid, rna in seqs.items():
        rna_fixed = fix_frame(rna)
        conv = rnaConverter(rna, frame_policy="truncate")
        # protein 1-letter for compactness
        protein_seq = "".join(conv.rna_to_protein(one_letter=True))
        aa_len = len(protein_seq)
        codon_usage_global.update(conv.analyze_codon_usage())

        orfs = conv.find_open_reading_frames(one_letter=True, include_partial=True, min_len=0)
        orf_lengths.extend(len(o) for o in orfs)
        if orfs:
            # store up to 3 examples per sequence
            orf_examples[sid] = orfs[:3]

        rows.append(
            {
                "id": sid,
                "rna_len": len(conv.rna_sequence),
                "aa_len": aa_len,
                "protein (1-letter)": protein_seq[:200] + ("..." if len(protein_seq) > 200 else ""),
            }
        )

    df = pd.DataFrame(rows).sort_values("aa_len", ascending=False).reset_index(drop=True)
    # filter by length uses protein length here
    df_f = df.copy()
    if min_len > 0:
        df_f = df_f[df_f["aa_len"] >= min_len]
    if max_len > 0:
        df_f = df_f[df_f["aa_len"] <= max_len]

    t1, t2, t3 = st.tabs(["Summary", "Distributions", "Details"])

    with t1:
        c1, c2, c3 = st.columns(3)
        c1.metric("Sequences", f"{len(df_f):,}".replace(",", " "))
        c2.metric("Mean AA length", f"{df_f['aa_len'].mean():.1f}" if len(df_f) else "â€“")
        c3.metric("Median AA length", f"{df_f['aa_len'].median():.1f}" if len(df_f) else "â€“")
        st.dataframe(df_f, use_container_width=True)

    with t2:
        st.subheader("Protein length histogram")
        if len(df_f):
            st.altair_chart(
                length_barchart(df_f["aa_len"], "Protein length distribution", "length (aa)"),
                use_container_width=True
            )

        st.subheader(f"Top {top_n} codons")
        if codon_usage_global:
            codon_df = pd.DataFrame(codon_usage_global.items(), columns=["codon", "count"]).sort_values(
                "count", ascending=False
            ).head(top_n).set_index("codon")
            st.bar_chart(codon_df)

        st.subheader("ORF length histogram")
        if orf_lengths:
            s_orf = pd.Series(orf_lengths)
            st.altair_chart(
                length_barchart(s_orf, "ORF length distribution", "length (aa)"),
                use_container_width=True
            )

        st.markdown("#### Example ORFs")
        for sid, orfs in list(orf_examples.items())[:3]:  # show up to 3 sequences with ORFs
            st.write(f"**{sid}**:")
            for i, orf in enumerate(orfs, start=1):
                st.code(orf, language="text")

    with t3:
        st.download_button(
            "Download CSV",
            df_f.to_csv(index=False).encode("utf-8"),
            file_name="rna_protein_stats.csv",
            mime="text/csv",
        )
        html = build_html_report(
            title="RNAâ†’Protein Report",
            sections=[
                ("Summary metrics",
                    f"<ul>"
                    f"<li>Sequences: <b>{len(df_f)}</b></li>"
                    f"<li>Mean AA length: <b>{(df_f['aa_len'].mean() if len(df_f) else 0):.1f}</b></li>"
                    f"<li>Median AA length: <b>{(df_f['aa_len'].median() if len(df_f) else 0):.1f}</b></li>"
                    f"</ul>"),
                ("Per-sequence table", html_table_from_df(df_f)),
            ],
        )
        st.download_button("Download HTML report", html, file_name="rna_protein_report.html", mime="text/html")

# ============= PROTEIN MODE =============
else:  # Protein
    rows = []
    aa_global = Counter()

    for sid, aa in seqs.items():
        try:
            p = proteinOperations(aa)
        except ValueError:
            continue
        counts = p.count_amino_acids()
        aa_global.update(counts)
        rows.append(
            {
                "id": sid,
                "length": len(aa),
                "MW (Da)": p.molecular_weight(),
                "pI (approx)": p.isoelectric_point(),
                "Hydrophobicity": p.hydrophobicity_score(),
            }
        )

    df = pd.DataFrame(rows).sort_values("length", ascending=False).reset_index(drop=True)
    df_f = apply_length_filters(df)

    t1, t2, t3 = st.tabs(["Summary", "Distributions", "Details"])

    with t1:
        c1, c2, c3, c4 = st.columns(4)
        c1.metric("Sequences", f"{len(df_f):,}".replace(",", " "))
        c2.metric("Mean length", f"{df_f['length'].mean():.1f}" if len(df_f) else "â€“")
        c3.metric("Median length", f"{df_f['length'].median():.1f}" if len(df_f) else "â€“")
        c4.metric("Mean MW (Da)", f"{df_f['MW (Da)'].mean():.1f}" if len(df_f) else "â€“")
        st.dataframe(df_f, use_container_width=True)

    with t2:
        st.subheader("Protein length histogram")
        if len(df_f):
            st.altair_chart(
                length_barchart(df_f["length"], "Protein length distribution", "length (aa)"),
                use_container_width=True
            )
            
        st.subheader(f"Top {top_n} amino acids")
        if aa_global:
            aa_df = (
                pd.DataFrame(aa_global.items(), columns=["aa", "count"])
                .sort_values("count", ascending=False)
                .head(top_n)
                .set_index("aa")
            )
            st.bar_chart(aa_df)

    with t3:
        st.download_button(
            "Download CSV",
            df_f.to_csv(index=False).encode("utf-8"),
            file_name="protein_stats.csv",
            mime="text/csv",
        )
        html = build_html_report(
            title="Protein Statistics Report",
            sections=[
                ("Summary metrics",
                 f"<ul>"
                 f"<li>Sequences: <b>{len(df_f)}</b></li>"
                 f"<li>Mean length: <b>{(df_f['length'].mean() if len(df_f) else 0):.1f}</b></li>"
                 f"<li>Median length: <b>{(df_f['length'].median() if len(df_f) else 0):.1f}</b></li>"
                 f"<li>Mean MW (Da): <b>{(df_f['MW (Da)'].mean() if len(df_f) else 0):.1f}</b></li>"
                 f"</ul>"),
                ("Per-sequence table", html_table_from_df(df_f)),
            ],
        )
        st.download_button("Download HTML report", html, file_name="protein_report.html", mime="text/html")


st.caption("UI: Streamlit Â· Core logic: `fasta_processing` package")